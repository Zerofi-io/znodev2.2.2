#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

LOG_FILE="$SCRIPT_DIR/znode.log"
PID_FILE="$SCRIPT_DIR/znode.pid"
AGG_LOG_FILE="$SCRIPT_DIR/cluster-aggregator.log"
AGG_PID_FILE="$SCRIPT_DIR/cluster-aggregator.pid"
SERVICE_NAME="znode.service"
SERVICE_FILE="/etc/systemd/system/$SERVICE_NAME"

INSTALL_STATE_DIR="$SCRIPT_DIR/.znode-install"
DEPS_LOCK_HASH_FILE="$INSTALL_STATE_DIR/npm-prod.lock.sha256"

log() {
  echo "$@"
}

hash_file() {
  local file="$1"
  if command -v sha256sum >/dev/null 2>&1; then
    sha256sum "$file" | awk '{print $1}'
    return 0
  fi
  if command -v shasum >/dev/null 2>&1; then
    shasum -a 256 "$file" | awk '{print $1}'
    return 0
  fi
  return 1
}

rotate_logs() {
  local file="$1"
  local max_mb="${MAX_LOG_SIZE_MB:-100}"
  local max_files="${MAX_LOG_FILES:-5}"
  if [ -f "$file" ]; then
    local size
    size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo 0)
    local max_bytes=$((max_mb * 1024 * 1024))
    if [ "$size" -ge "$max_bytes" ]; then
      log "[start] Rotating logs (size: $((size / 1024 / 1024))MB)..."
      for i in $(seq $((max_files - 1)) -1 1); do
        [ -f "${file}.$i" ] && mv "${file}.$i" "${file}.$((i + 1))"
      done
      mv "$file" "${file}.1"
      touch "$file"
    fi
  fi
}

ensure_time_sync() {
  if [ "${SKIP_TIME_SYNC_CHECK:-0}" = "1" ]; then
    log "[start] SKIP_TIME_SYNC_CHECK=1 set; skipping clock sync check."
    return 0
  fi

  if ! command -v timedatectl >/dev/null 2>&1; then
    log "[start] ERROR: timedatectl not found; cannot verify clock sync state."
    log "[start] Install systemd tools or set SKIP_TIME_SYNC_CHECK=1 to bypass."
    exit 1
  fi

  local synced
  synced="$(timedatectl show -p SystemClockSynchronized --value 2>/dev/null || true)"
  if [ -z "$synced" ]; then
    if timedatectl status 2>/dev/null | grep -q "System clock synchronized: yes"; then
      synced="yes"
    else
      synced="no"
    fi
  fi

  if [ "$synced" = "yes" ]; then
    return 0
  fi

  log "[start] System clock not synchronized; attempting to enable NTP/time sync..."

  if [ "$(id -u)" -ne 0 ]; then
    if ! command -v sudo >/dev/null 2>&1; then
      log "[start] ERROR: sudo not found; cannot enable time sync automatically."
      log "[start] Run: sudo timedatectl set-ntp true"
      log "[start] Then verify: timedatectl status"
      exit 1
    fi

    if sudo -n true >/dev/null 2>&1; then
      sudo timedatectl set-ntp true >/dev/null 2>&1 || true
      sudo systemctl restart systemd-timesyncd >/dev/null 2>&1 || true
    else
      if [ ! -t 0 ]; then
        log "[start] ERROR: Clock not synchronized and no TTY available for sudo."
        log "[start] Run: sudo timedatectl set-ntp true"
        log "[start] Then verify: timedatectl status"
        exit 1
      fi

      sudo timedatectl set-ntp true >/dev/null 2>&1 || true
      sudo systemctl restart systemd-timesyncd >/dev/null 2>&1 || true
    fi
  else
    timedatectl set-ntp true >/dev/null 2>&1 || true
    systemctl restart systemd-timesyncd >/dev/null 2>&1 || true
  fi

  local timeout_s="${TIME_SYNC_TIMEOUT_S:-60}"
  local i=0
  while [ "$i" -lt "$timeout_s" ]; do
    synced="$(timedatectl show -p SystemClockSynchronized --value 2>/dev/null || true)"
    if [ "$synced" = "yes" ]; then
      return 0
    fi
    i=$((i + 1))
    sleep 1
  done

  log "[start] ERROR: System clock still not synchronized after ${timeout_s}s."
  log "[start] Check: timedatectl status"
  exit 1
}

ensure_env() {
  if [ -f "$SCRIPT_DIR/.env" ]; then
    return 0
  fi

  log "[start] Missing .env file; running sudo scripts/setup.sh to create it..."

  if [ ! -t 0 ]; then
    log "[start] ERROR: No TTY available for interactive setup."
    log "[start] Run: sudo ./scripts/setup.sh"
    exit 1
  fi

  sudo "$SCRIPT_DIR/scripts/setup.sh"
}

ensure_node_deps() {
  local lockfile="$SCRIPT_DIR/package-lock.json"
  local deps_dir="$SCRIPT_DIR/node_modules"

  if [ "${REINSTALL_NODE_DEPS:-0}" = "1" ]; then
    log "[start] REINSTALL_NODE_DEPS=1 set; forcing reinstall of Node dependencies."
    rm -rf "$deps_dir" 2>/dev/null || true
  fi

  if [ ! -f "$SCRIPT_DIR/package.json" ]; then
    log "[start] ERROR: package.json not found."
    exit 1
  fi

  if ! command -v npm >/dev/null 2>&1; then
    log "[start] ERROR: npm not found. Install Node.js + npm or run sudo ./scripts/setup.sh"
    exit 1
  fi

  mkdir -p "$INSTALL_STATE_DIR" 2>/dev/null || true

  local need_install=0
  if [ ! -d "$deps_dir" ]; then
    need_install=1
  fi

  if [ "$need_install" -eq 0 ]; then
    if [ ! -d "$deps_dir/dotenv" ] || [ ! -d "$deps_dir/ethers" ]; then
      need_install=1
    fi
  fi

  if [ -f "$lockfile" ]; then
    local cur_hash=""
    if cur_hash="$(hash_file "$lockfile" 2>/dev/null)"; then
      :
    else
      log "[start] WARNING: Unable to hash $lockfile; falling back to checking node_modules presence only."
      cur_hash=""
    fi

    local stored_hash=""
    if [ -f "$DEPS_LOCK_HASH_FILE" ]; then
      stored_hash="$(cat "$DEPS_LOCK_HASH_FILE" 2>/dev/null || true)"
    fi

    if [ -n "$cur_hash" ] && [ -n "$stored_hash" ] && [ "$cur_hash" != "$stored_hash" ]; then
      need_install=1
    fi

    if [ "$need_install" -eq 1 ]; then
      log "[start] Installing Node dependencies (npm ci --omit=dev)..."
      npm ci --omit=dev --silent 2>/dev/null || npm ci --omit=dev
      if [ -n "$cur_hash" ]; then
        echo "$cur_hash" > "$DEPS_LOCK_HASH_FILE" 2>/dev/null || true
      fi
      return 0
    fi

    if [ -n "$cur_hash" ] && [ ! -f "$DEPS_LOCK_HASH_FILE" ]; then
      echo "$cur_hash" > "$DEPS_LOCK_HASH_FILE" 2>/dev/null || true
    fi

    return 0
  fi

  if [ "$need_install" -eq 1 ]; then
    log "[start] Installing Node dependencies (npm install --omit=dev)..."
    npm install --omit=dev --silent 2>/dev/null || npm install --omit=dev
  fi
}

resolve_go_bin() {
  if [ -n "${GO_BIN:-}" ]; then
    echo "$GO_BIN"
    return 0
  fi
  if [ -x "/usr/local/go/bin/go" ]; then
    echo "/usr/local/go/bin/go"
    return 0
  fi
  if command -v go >/dev/null 2>&1; then
    command -v go
    return 0
  fi
  return 1
}

require_go_version() {
  local go_bin="$1"
  local v
  v="$($go_bin version 2>/dev/null | awk '{print $3}')"
  v="${v#go}"
  local major="${v%%.*}"
  local rest="${v#*.}"
  local minor="${rest%%.*}"
  if [ -z "$major" ] || [ -z "$minor" ]; then
    log "[start] ERROR: Unable to determine Go version."
    exit 1
  fi
  if [ "$major" -lt 1 ] || { [ "$major" -eq 1 ] && [ "$minor" -lt 24 ]; }; then
    log "[start] ERROR: Go 1.24+ is required (found go$v)."
    exit 1
  fi
  local required_prefix="${GO_REQUIRED_PREFIX:-go1.24.}"
  if [ -n "$required_prefix" ]; then
    local raw="go$v"
    if [[ "$raw" != "$required_prefix"* ]]; then
      log "[start] ERROR: Go toolchain mismatch: need prefix $required_prefix (found $raw)."
      exit 1
    fi
  fi
}

p2p_daemon_needs_build() {
  local p2p_bin="$SCRIPT_DIR/p2p-daemon/p2p-daemon"
  local mode="${P2P_DAEMON_BUILD_MODE:-auto}"
  if [ "${REBUILD_P2P_DAEMON:-0}" = "1" ]; then
    mode="always"
  fi
  if [ "$mode" = "never" ]; then
    return 1
  fi
  if [ "$mode" = "always" ]; then
    return 0
  fi
  if [ ! -f "$p2p_bin" ]; then
    return 0
  fi
  if find "$SCRIPT_DIR/p2p-daemon" -type f \
      \( -name '*.go' -o -name 'go.mod' -o -name 'go.sum' \) \
      -newer "$p2p_bin" -print -quit | grep -q .; then
    return 0
  fi
  return 1
}

build_p2p_daemon() {
  local go_bin
  if ! go_bin="$(resolve_go_bin)"; then
    log "[start] ERROR: Go is not installed. Install Go 1.24+ or set P2P_DAEMON_BUILD_MODE=never."
    exit 1
  fi
  require_go_version "$go_bin"
  (cd "$SCRIPT_DIR/p2p-daemon" && "$go_bin" build -trimpath -buildvcs=false -o p2p-daemon .)
}

ensure_p2p_daemon() {
  if p2p_daemon_needs_build; then
    log "[start] Building p2p-daemon..."
    build_p2p_daemon
    log "[start] p2p-daemon built successfully."
  fi

  local p2p_bin="$SCRIPT_DIR/p2p-daemon/p2p-daemon"
  if [ ! -x "$p2p_bin" ]; then
    log "[start] ERROR: p2p-daemon binary not found: $p2p_bin"
    log "[start] Tip: run 'cd p2p-daemon && go build' or allow builds by setting P2P_DAEMON_BUILD_MODE=auto"
    exit 1
  fi
}

if [ -f "$SERVICE_FILE" ] && systemctl is-active --quiet "$SERVICE_NAME"; then
  log "[start] Using systemd service..."
  log "[start] znode is already running via systemd."
  exit 0
fi

ensure_time_sync
ensure_env
ensure_node_deps
ensure_p2p_daemon

if [ -f "$SERVICE_FILE" ]; then
  log "[start] Using systemd service..."

  rotate_logs "$LOG_FILE"

  systemctl start "$SERVICE_NAME"
  sleep 2

  if systemctl is-active --quiet "$SERVICE_NAME"; then
    log "[start] znode started successfully via systemd."
    log "[start] View logs: tail -f $LOG_FILE"
  else
    log "[start] Failed to start znode. Check: journalctl -u znode -n 50"
    exit 1
  fi

  exit 0
fi

log "[start] No systemd service found, using legacy startup..."

start_cluster_aggregator() {
  log "[start] Starting cluster-aggregator on port ${CLUSTER_AGG_PORT:-4000}..."

  if [ -f "$AGG_PID_FILE" ]; then
    local OLD_AGG_PID
    OLD_AGG_PID="$(cat "$AGG_PID_FILE" 2>/dev/null || true)"
    if [ -n "$OLD_AGG_PID" ] && kill -0 "$OLD_AGG_PID" 2>/dev/null; then
      log "[start] cluster-aggregator already running (PID $OLD_AGG_PID), skipping."
      return 0
    fi
    rm -f "$AGG_PID_FILE" 2>/dev/null || true
  fi

  set +e
  nohup node cluster-aggregator.js >> "$AGG_LOG_FILE" 2>&1 &
  local AGG_PID=$!
  local RC=$?
  set -e

  if [ "$RC" -ne 0 ]; then
    log "[start] WARNING: failed to start cluster-aggregator (exit $RC). Check $AGG_LOG_FILE"
    return 0
  fi

  echo "$AGG_PID" > "$AGG_PID_FILE"
  log "[start] cluster-aggregator started (PID $AGG_PID)"
}

LOG_MAX_AGE_MIN="${LOG_MAX_AGE_MIN:-1440}"
rotate_logs "$LOG_FILE"

find "$SCRIPT_DIR" -maxdepth 1 -name "znode.log.*" -type f -mmin +$LOG_MAX_AGE_MIN -delete 2>/dev/null || true

if [ -f "$PID_FILE" ]; then
  OLD_PID="$(cat "$PID_FILE" 2>/dev/null || true)"
  if [ -n "$OLD_PID" ] && kill -0 "$OLD_PID" 2>/dev/null; then
    log "[start] znode is already running (PID $OLD_PID). Use ./stop first."
    exit 1
  fi
  rm -f "$PID_FILE"
fi

log "[start] Note: ensure TCP port 9000 is open inbound for P2P."

./scripts/start-monero-rpc.sh

log "[start] Starting znode..."
nohup node node.js >> "$LOG_FILE" 2>&1 &
NODE_PID=$!
echo "$NODE_PID" > "$PID_FILE"

sleep 2
if kill -0 "$NODE_PID" 2>/dev/null; then
  log "[start] znode started (PID $NODE_PID)"
  log "[start] View logs: tail -f $LOG_FILE"
  start_cluster_aggregator || true
else
  log "[start] Failed to start znode. Check $LOG_FILE for errors."
  rm -f "$PID_FILE"
  exit 1
fi
